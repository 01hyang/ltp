# vi: set ts=8 sw=8 autoindent noexpandtab :
################################################################################
##									      ##
## (C) Copyright IBM Corp. 2003						      ##
##									      ##
## This program is free software;  you can redistribute it and#or modify      ##
## it under the terms of the GNU General Public License as published by       ##
## the Free Software Foundation; either version 2 of the License, or	      ##
## (at your option) any later version.					      ##
##									      ##
## This program is distributed in the hope that it will be useful, but	      ##
## WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY ##
## or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License   ##
## for more details.							      ##
##									      ##
## You should have received a copy of the GNU General Public License	      ##
## along with this program;  if not, write to the Free Software		      ##
## Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA    ##
##									      ##
################################################################################
#
# File :	utility.source
#
# Description:	Utility functions to be used by shell script testcases.
#		Shell script testcases should source this file near the
#		beginning of the file. This should be done as follows:
#
#		cd `dirname $0`
#		LTPBIN=${PWD%%/testcases/*}/testcases/bin
#		source $LTPBIN/utility.source
#
# Author:	Robert Paulsen, rpaulsen@us.ibm.com
#
# History:	Feb 27 2003 - Created. Robert Paulsen. rpaulsen@us.ibm.com
#		Mar 05 2003 - Added "maybefail".
#		Mar 14 2003 - Added ability to create multiple temp users and
#			groups.
#		Mar 14 2003 - Improved the "executes" test to use "type"
#			instead of "which". This makes it work for builtins
#			when invoked from a script (as it is intended to be).
#		Mar 21 2003 - Break rest of testcases if TST_COUNT != TST_TOTAL
#			upon final exit.
#		Mar 31 2003 - Now includes rc and stdout in failure output.
#		May 13 2003 - Added "busyboxsh" function.

################################################################################
# global variables
################################################################################

# interface to the PAN test harness
declare -i TST_TOTAL TST_COUNT
export TCID=${0##*/}	# Name of executable containing the testcases.
[ "$TST_TOTAL" ] || export TST_TOTAL=1	# Total number of testcases in file
					# 1 is the default
export TST_COUNT=0	# Current testcases's sequence number

# track temp users and groups
declare -i u_ndx=0	# count temp users
declare -i g_ndx=0	# count temp groups
t_users=""		# hplds all temp users
t_groups=""		# holds all temp groups
temp_user=""		# will be set when a temp user is created
temp_group=""		# will be set when a temp group is created

# for use by testcase - setup fills them in
stdout=""		# testcases can put stdout in this file (set in setup)
stderr=""		# testcases can put stderr in this file (set in setup)
TCTMP=""		# subdir for use by the testcase (a subdir of MYTMP)

# will be set to name of currently executing testcase. used in output.
TCNAME=""

# final exit code. set by passfail. returned by cleanup.
declare -i final_result=0	# will be count of failures

# if final exit code (above) is zero, will return this BROK code,
declare -i brok_result=0	# 0 and -1 are only allowed values.

MYTMP=""		# if setup creates the temp dir, remember it here for
			# cleanup to delete.

################################################################################
# utility functions
################################################################################

#
# executes	Check for required commands.
#
#		Breaks testcase if commands listed on command line do not
#		exist.  Returns true or false leaving the exit/no-exit decision
#		to invoker.
#
#	returns 0 if true
#	returns 1 if not
#
function executes()
{
	local cmd broke=""
	for cmd in "$@" ; do
		if ! type $cmd &>/dev/null ; then
			tst_resm TINFO \
				"$TCNAME: required command \"$cmd\" not found"
			brok_result=-1
			broke="yes"
		fi
	done
	if [ "$broke" = "yes" ] ; then
		tst_resm TBROK \
			"$TCNAME: above listed required command(s) not found"
		return	1
	fi
	return 0
}

#
# exists	Check for the existence of files or directories.
#
#		Breaks testcase if files or directories listed on command line
#		do not exist. Returns true or false leaving the exit/no-exit
#		decision to the invoker.
#
#	returns 0 if true
#	returns 1 if not
#	
function exists()
{
	local f broke=""
	for f in "$@" ; do
		if [ ! -e "$f" ] ; then
			tst_resm TINFO \
				"$TCNAME: required file \"$f\" not found"
			brok_result=-1
			broke="yes"
		fi
	done
	if [ "$broke" = "yes" ] ; then
		tst_resm TBROK \
			"$TCNAME: above listed required files(s) not found"
		return	1
	fi
	return 0
}

#
# isroot	Are we running as root?  Returns true or false leaving the
#		exit/no-exit decision to invoker.
#
#	returns 0 if true
#	returns 1 if not
#
function isroot()
{
	# This testcase must be run as root.
	if [ $UID -ne 0 ] ; then
		tst_resm TBROK "$TCNAME: Must be run by UID=0. Actual UID=$UID"
		return 1
	fi
	return 0
}

#
# busyboxcmd	Are we using a busybox version of some command
#
#	$1	Command to check to see if it is a busybox version
#
#	returns 0 if true
#	returns 1 if not
#
function busyboxcmd()
{
	local bbcmd=$('ls' -l `which $1`)	# quoted ls in case of alias
	[ "${bbcmd##*/}" = "busybox" ] && return 0
	return 1
}

#
# path_is_fstype	Check to see if a given path is mounted on a given
#			filesystem type
#
#	$1	fully-qualified path
#	$2	the filesystem type
#
#	returns 0 if true
#	returns 1 if not
#
#	Example:	path_is_fstype $TCTMP nfs
#
#			This returns true if $TCTMP is on an NFS-mounted
#			filesystem
#
function path_is_fstype()
{
        path=$1
        fstype=$2
        while [ $path ] ; do
                while read line ; do
                        set $line
                        procpath=$2
                        proctype=$3
                        [ "$proctype" = "$fstype" ] || continue
                        [ "$path" = "$procpath" ] && return
                done < /proc/mounts
                [ "$path" = "/" ] && break
                path=${path%/*}
                [ "$path" ] || path="/"
        done
        return 1
}

#
# add_tempuser	Create a temporary user.
#
#		This function will generate a unique name for the temp user
#		unless the username is passed as $1. In either case, the
#		username is placed in global variable $temp_user.
#
#		The user's password is set to "password".
#
#		Careful! If you call this more than once $temp_user will
#		be reused. You may need to save a copy.
#
#		del_tempuser w/o arguments will delete all of them.
#
#	returns 0 if successful
#	returns 1 if not
#
function add_tempuser()
{
	executes useradd || return 
	if [ "$1" ] ; then		# attempt to use supplied username
		u=$1
	else				# create unique username
		let u_ndx+=1		# count uniquely created usernames
		if [ $u_ndx -gt 99 ] ; then
			tst_resm TBROK "$TCNAME: too many temp users: $u_ndx"
			brok_result=-1
			return 1
		fi
		local nn="00$u_ndx"
		local -i off=-2		# negative offsets must be in variable (?)
		nn=${nn:off:2}		# two digits, 00 -> 99
		local u="u$$00000"	# at least 6 digits
		u=${u:0:6}$nn		# 8-char name from pid and temp user count
	fi
	if ! useradd -p .RkDISPQTFoMA -m $u &>$stderr ; then
		tst_res TBROK $stderr "$TCNAME: failed to add temp user $u"
		brok_result=-1
		return 1
	fi
	t_users="$t_users $u"	# remember all created temp users
	tst_resm TINFO "$TCNAME: created temp user $u."
	temp_user=$u
	return 0
}

#
# del_tempuser	Remove temporary user(s).
#
#	$1	The user to delete. If $1 not supplied, all temp users are
#		deleted.  If $1 was not created by add_tempuser it will not
#		be deleted.
#
#	No specific return code
#
function del_tempuser()
{
	local remaining=""
	for u in $t_users ; do
		if [ "$1" ] && [ "$1" != "$u" ] ; then
			# $1 specified so don't delete others
			remaining="$remaining $u"
			continue
		fi
		if userdel -r $u ; then 
			tst_resm TINFO "$TCNAME: removed temp user $u."
		else
			tst_brkm TBROK NULL \
				"$TCNAME: failed to remove temp user $u"
		fi
	done
	t_users="$remaining"
}

#
# add_tempgroup		Create a temporary group.
#
# 		The group name is put into the global variable $temp_group.
#		Careful! If you call this more than once $temp_group will
#		be reused. You may need to save a copy.
#
#		del_tempgroup w/o arguments will delete all of them.
#
#	returns 0 if successful
#	returns 1 if not
#
function add_tempgroup()
{
	executes groupadd || return 
	let g_ndx+=1		# count temp users
	if [ $g_ndx -gt 99 ] ; then
		tst_resm TBROK "$TCNAME: too many temp groups: $g_ndx"
		brok_result=-1
		return 1
	fi
	local nn="00$g_ndx"
	local -i off=-2		# negative offsets must be in variable (?)
	nn=${nn:off:2}		# two digits, 00 -> 99
	local g="g$$00000"	# at least 6 digits
	g=${g:0:6}$nn		# 8-char name from pid and temp group count
	if ! groupadd $g ; then
		tst_resm TBROK "failed to add temp group $g"
		brok_result=-1
		return 1
	fi
	t_groups="$t_groups $g"	# remember all created temp groups
	tst_resm TINFO "$TCNAME: created temp group $g."
	temp_group=$g
	return 0
}

#
# del_tempgroup		Remove temporary group(s).
#
#	$1	The group to delete. If $1 not supplied, all temp groups are
#		deleted.  If $1 was not created by add_tempgroup it will not
#		be deleted.
#
#	No specific return code
#
function del_tempgroup()
{
	local remaining=""
	for g in $t_groups ; do 
		if [ "$1" ] && [ "$1" != "$g" ] ; then
			# $1 specified so don't delete others
			remaining="$remaining $g"
			continue
		fi
		if groupdel $g ; then
			tst_resm TINFO "$TCNAME: removed temp group $g."
		else
			tst_brkm TBROK NULL \
				"$TCNAME: failed to remove temp group $g"
		fi
	done
	t_groups="$remaining"
}

#
# maybebrok	Break testcase if $1 has bad RC or if $stderr is not empty.
#
#		Incoming $1 is returned unless it is 0 and $stderr is not null
#		-- in which case 255 is returned to indiacate that it was
#		stderr that caused the failure.
#
#		If there is a failure ...
#		- Failure info (the remaining cmd-line args) is printed.
#		- $stdout is printed if not null.
#		- $stderr is printed if not null.
#
#	$1	0 (pass) or non-zero (fail)
#	$2	Printed only if the testcase fails
#	$3+	Others also printed on failure via TINFO
#
function maybebrok()
{
	local -i rc=$1

	# ignore if no problems
	[ "$rc" -eq 0 ] && [ ! -s $stderr ] && return 0

	# BROK
	tst_resm TBROK "$TCNAME: $2"
	shift ; shift			# get to args $3+
	for m in "$@" ; do
		tst_resm TINFO "$TCNAME: $m"
	done
	[ $rc -ne 0 ] && tst_resm TINFO "$TCNAME: rc=$rc"
	if [ -s $stdout ] ; then
		tst_resm TINFO \
		"$TCNAME: ================== stdout follows =================="
		cat $stdout
		echo ""
		tst_resm TINFO \
		"$TCNAME: =================== stdout above ==================="
		[ $rc -eq 0 ] && rc=255
		cat /dev/null > $stdout
	fi
	if [ -s $stderr ] ; then
		tst_resm TINFO \
		"$TCNAME: ================== stderr follows =================="
		cat $stderr
		echo ""
		tst_resm TINFO \
		"$TCNAME: =================== stderr above ==================="
		[ $rc -eq 0 ] && rc=255
		cat /dev/null > $stderr
	fi
	return $rc
}

#
# passfail	Pass or fail based on true/false input in $1.
#
#		Incoming $1 is returned unless it is 0 and $stderr is not null
#		-- in which case 255 is returned to indiacate that it was
#		stderr that caused the failure.
#
#		If there is a failure ...
#		- Failure info (the remaining cmd-line args) is printed.
#		- $stdout is printed if not null.
#		- $stderr is printed if not null.
#
#	$1	0 (pass) or non-zero (fail)
#	$2	Printed only if the testcase fails
#	$3+	Others also printed on failure via TINFO
#
function passfail()
{
	local -i rc=$1

	# PASS if no problems
	if [ "$rc" -eq 0 ] && [ ! -s $stderr ] ; then
		tst_resm TPASS "$TCNAME"
		return 0
	fi

	# FAIL
	let final_result+=1		# count failures for summary output
	tst_resm TFAIL "$TCNAME: $2"
	shift ; shift			# get to args $3+
	for m in "$@" ; do
		tst_resm TINFO "$TCNAME: $m"
	done
	[ $rc -ne 0 ] && tst_resm TINFO "$TCNAME: rc=$rc"
	if [ -s $stdout ] ; then
		tst_resm TINFO \
		"$TCNAME: ================== stdout follows =================="
		cat $stdout
		echo ""
		tst_resm TINFO \
		"$TCNAME: =================== stdout above ==================="
		[ $rc -eq 0 ] && rc=255
		cat /dev/null > $stdout
	fi
	if [ -s $stderr ] ; then
		tst_resm TINFO \
		"$TCNAME: ================== stderr follows =================="
		cat $stderr
		echo ""
		tst_resm TINFO \
		"$TCNAME: =================== stderr above ==================="
		[ $rc -eq 0 ] && rc=255
		cat /dev/null > $stderr
	fi
	return $rc
}

#
# maybefail	If $1 is non-zero or if $stderr file is not empty,
#		invoke passfail. Otherwise simply return (with rc=0)
#
#	$@	Command line args are as described for passfail
#
function maybefail()
{
	if [ "$1" -ne 0 ] || [ -s $stderr ] ; then
		passfail "$@"
		return $?	# Pass along rc from passfail.
	fi
	return 0		# pass along original rc of 0
}

#
# register_tc	Register a testcase.
#
#		These are some things that commonly need to be done at the
#		start of each individual testcase.  Perhaps not suitable for
#		all situations.
#
#	$1	TCNAME
#
#	No specific return code.
#
function register_tc()
{
	TCNAME="$1"
	let TST_COUNT+=1
	cat /dev/null > $stdout
	cat /dev/null > $stderr
}

#
# local_setup	For individual testcases to override
#
function local_setup()
{
	return 0
}

#
# setup		testcase setup
#
#	input: none
#
#	output:	returns 0 on success.
#		exits (not returns) with 1 on failure
#
function setup()
{
	TCNAME=setup

	# Establish LTPBIN path.  This is also a handy place to have support
	# files copied to by "make install", making them readily available to
	# the testcase. ASSUMES: $PWD is beneath LTP's "testcases" directory.
	LTPBIN=${PWD%%/testcases/*}/testcases/bin
	export PATH=$LTPBIN:$PATH

	# See that we have access to the API utilities
	if [ -z "`type tst_resm 2>/dev/null`" ] ; then
		>&2 echo "tst_* utilities not found in path: $PATH"
		exit 1
	fi

	# Trap exit for cleanup function.
	trap "cleanup" 0

	# Ensure required utilities are present
	executes cat mkdir umask || exit 1

	# PAN harness messes this up - fix it
	umask 022

	# Establish temp directory if not supplied by harness
	if ! [ -d "$TMP" ] ; then
		MYTMP=/tmp/tmp$$
		mkdir -p $MYTMP		# create it
		TMP=$MYTMP
	fi

	# tmp subdirectory just for this executable
	TCTMP=$TMP/$TCID$$
	rm -rf $TCTMP		# ensure empty in case of multiple invocations
	mkdir -p $TCTMP

	# Where stdout and stderr can be redirected
	stdout="$TCTMP/stdout"
	cat /dev/null > $stdout
	stderr="$TCTMP/stderr"
	cat /dev/null > $stderr

	tst_resm TINFO "standard setup complete"

	TCNAME=local_setup
	local_setup || exit	# call testcase's setup, if any
}

#
# local_cleanup		For individual testcases to override
#
function local_cleanup()
{
	return 0
}

#
# cleanup	testcase cleanup (reached via trap 0)
#
#	input:	None.
#
#	output:	If passfail has registered any failure(s), exits with count of
#		failures (which will be in $final_result).  If no failure
#		occured perhaps there was a BROK. If so exit with $brok_result.
#		Otherwise exit with 0.
#
function cleanup()
{
	TCNAME=local_cleanup
	local_cleanup			# call testcase's cleanup, if any
	TCNAME=cleanup
	del_tempuser
	del_tempgroup
	[ "$MYTMP" ] && rm -rf $MYTMP	# supplied by setup so delete it
	if [ $TST_COUNT -lt $TST_TOTAL ] ; then
		let TST_COUNT+=1
		tst_brkm TBROK NULL "Remaining cases broken"
	fi
	[ $final_result -ne 0 ] && exit $final_result
	[ $brok_result -ne 0 ] && exit $brok_result
	exit 0
}
