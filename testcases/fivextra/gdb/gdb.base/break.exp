#   Copyright 1988, 1990, 1991, 1992, 1994, 1995, 1996, 1997, 1998, 1999,
#   2000
#   Free Software Foundation, Inc.

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  

# Please email any bugs, comments, and/or additions to this file to:
# bug-gdb@prep.ai.mit.edu

# This file was written by Rob Savoye. (rob@cygnus.com)
set testfile [lindex $argv 0]
set timeout 3
source "gdb.base/gdb_fun.exp"
spawn gdb
gdb_start
send "dir gdb.base/ \n"
send "file $testfile \n"

#
# test simple breakpoint setting commands
#

# Test deleting all breakpoints when there are none installed,
# GDB should not prompt for confirmation.
# Note that gdb-init.exp provides a "delete_breakpoints" proc
# for general use elsewhere.

send "delete breakpoints\n"
expect {
     -re "Delete all breakpoints.*$" {
	    send "y\n"
	    expect {
		-re "$gdb_prompt $" {
		    fail "Delete all breakpoints when none (unexpected prompt)"
		}
		timeout	{ fail "Delete all breakpoints when none (timeout after unexpected prompt)" }
	    }
	}
     -re ".*$gdb_prompt $"       { pass "Delete all breakpoints when none" }
    timeout	            { fail "Delete all breakpoints when none (timeout)" }
}

#
# test break at function
#
gdb_test "break main" \
    "Breakpoint.*at.* file .*, line.*" \
    "breakpoint function"

#
# test break at function in file
#
gdb_test "break factorial" \
    "Breakpoint.*at.* file .*, line.*" \
    "breakpoint function in file"

#
# test break at line number
#
# Note that the default source file is the last one whose source text
# was printed.  For native debugging, before we've executed the
# program, this is the file containing main, but for remote debugging,
# it's wherever the processor was stopped when we connected to the
# board.  So, to be sure, we do a list command.
#
gdb_test "list main" \
    ".*main \\(argc, argv, envp\\).*" \
    "use `list' to establish default source file"
gdb_test "break 79" \
    "Breakpoint.*at.* file .*, line 79\\." \
    "breakpoint line number"

#
# test duplicate breakpoint
#
gdb_test "break 79" \
    "Note: breakpoint \[0-9\]+ also set at pc.*Breakpoint \[0-9\]+ at.* file .*, line 79\\." \
    "breakpoint duplicate"

#
# test break at line number in file
#
gdb_test "break 85" \
    "Breakpoint.*at.* file .*, line 85\\." \
    "breakpoint line number in file"


#
# Test putting a break at the start of a multi-line if conditional.
# Verify the breakpoint was put at the start of the conditional.
#
gdb_test "break multi_line_if_conditional" \
    "Breakpoint.*at.* file .*, line 109\\." \
    "breakpoint at start of multi line if conditional"

gdb_test "break multi_line_while_conditional" \
    "Breakpoint.*at.* file .*, line 124\\." \
    "breakpoint at start of multi line while conditional"

#

set proto ""
gdb_test "info break" \
    "Num Type\[ \]+Disp Enb Address\[ \]+What.*
\[0-9\]+\[\t \]+breakpoint     keep y.* in main at .*
\[0-9\]+\[\t \]+breakpoint     keep y.* in factorial$proto at .*:96.*
\[0-9\]+\[\t \]+breakpoint     keep y.* in main at .*:79.*
\[0-9\]+\[\t \]+breakpoint     keep y.* in main at .*:79.*
\[0-9\]+\[\t \]+breakpoint     keep y.* in main at .*:85.*
\[0-9\]+\[\t \]+breakpoint     keep y.* in multi_line_if_conditional at .*:109.*
\[0-9\]+\[\t \]+breakpoint     keep y.* in multi_line_while_conditional at .*:124" \
    "breakpoint info"

send  "run \r"

# run until the breakpoint at a line number
#
gdb_test continue "Continuing\\..*Breakpoint \[0-9\]+, main \\(argc=.*, argv=.*, envp=.*\\) at .*:79.*79\[\t \]+printf.*factorial.*" \
			"run until breakpoint set at a line number"

#
# Run until the breakpoint set in a function in a file
#
for {set i 6} {$i >= 1} {incr i -1} {
	gdb_test continue "Continuing\\..*Breakpoint \[0-9\]+, factorial \\(value=$i\\) at .*:96.*96\[\t \]+.*if .value > 1. \{.*" \
			"run until file:function($i) breakpoint"
}

#
# run until the file:function breakpoint at a line number in a file
#
gdb_test continue "Continuing\\..*Breakpoint \[0-9\]+, main \\(argc=.*, argv=.*, envp=.*\\) at .*:85.*85\[\t \]+argc = \\(argc == 12345\\);.*" \
		"run until file:linenum breakpoint"

# Test break at offset +1

gdb_test "break +1" \
    "Breakpoint.*at.* file .*, line 86\\." \
    "breakpoint offset +1"

# Check to see if breakpoint is hit when stepped onto

gdb_test "step" \
    ".*Breakpoint \[0-9\]+, main \\(argc=.*, argv=.*, envp=.*\\) at .*:86.*86\[\t \]+return argc;" \
    "step onto breakpoint"

#
# delete all breakpoints so we can start over, course this can be a test too
#
delete_breakpoints

#
# test temporary breakpoint at function
#

gdb_test "tbreak main" "Breakpoint.*at.* file .*, line.*" "Temporary breakpoint function"

#
# test break at function in file
#

gdb_test "tbreak factorial" "Breakpoint.*at.* file .*, line.*" \
	"Temporary breakpoint function in file"

#
# test break at line number
#
send "tbreak 79\n"
expect {
    -re "Breakpoint.*at.* file .*, line 79.*$gdb_prompt $" { pass "Temporary breakpoint line number #1" }
	-re ".*$gdb_prompt $"   { pass "Temporary breakpoint line number #1" }
	timeout	    { fail "breakpoint line number #1 (timeout)" }
}

gdb_test "tbreak 75" "Breakpoint.*at.* file .*, line 75.*" "Temporary breakpoint line number #2"

#
# test break at line number in file
#
send "tbreak 85\n"
expect {
    -re "Breakpoint.*at.* file .*, line 85.*$gdb_prompt $" { pass "Temporary breakpoint line number in file #1" }
	-re ".*$gdb_prompt $"   { pass "Temporary breakpoint line number in file #1" }
	timeout	    { fail "Temporary breakpoint line number in file #1 (timeout)" }
}

gdb_test  "tbreak 81" "Breakpoint.*at.* file .*, line 81.*" "Temporary breakpoint line number in file #2"

#
# check to see what breakpoints are set (temporary this time)
#
gdb_test "info break" "Num Type.*Disp Enb Address.*What.*\[\r\n\]
\[0-9\]+\[\t \]+breakpoint     del.*y.*in main at .*\[\r\n\]
\[0-9\]+\[\t \]+breakpoint     del.*y.*in factorial$proto at .*:96.*\[\r\n\]
\[0-9\]+\[\t \]+breakpoint     del.*y.*in main at .*:79.*\[\r\n\]
\[0-9\]+\[\t \]+breakpoint     del.*y.*in main at .*:75.*\[\r\n\]
\[0-9\]+\[\t \]+breakpoint     del.*y.*in main at .*:85.*\[\r\n\]
\[0-9\]+\[\t \]+breakpoint     del.*y.*in main at .*:81.*" \
    "Temporary breakpoint info"


#***********

# Verify that catchpoints for fork, vfork and exec don't trigger
# inappropriately.  (There are no calls to those system functions
# in this test program.)
#
if ![runto main] then { fail "break tests suppressed" }
expect {
	-re "$gdb_prompt $" { pass "run to main\n" }
	timeout {fail "run to main\n" }
	}
send "catch \r"
expect {
  -re "Catch requires an event name.*$gdb_prompt $"\
          {pass "catch requires an event name"}
  -re "$gdb_prompt $"\
          {fail "catch requires an event name"}
  timeout {fail "(timeout) catch requires an event name"}
}


set name "set catch fork, never expected to trigger"
send "catch fork\n"
expect {
  -re "Catchpoint \[0-9\]* .fork..*$gdb_prompt $"
          {pass $name}
  -re "Catch of fork not yet implemented.*$gdb_prompt $"
	  {pass $name}
  -re "$gdb_prompt $"
          {fail $name}
  timeout {fail "(timeout) $name"}
}


set name "set catch vfork, never expected to trigger"
send "catch vfork\n"
    expect {
	-re "Catchpoint \[0-9\]* .vfork..*$gdb_prompt $"
		{pass $name}
	-re "Catch of vfork not yet implemented.*$gdb_prompt $"
		{pass $name}
	-re "$gdb_prompt $"
		{fail $name}
	timeout {fail "(timeout) $name"}
    }

set name "set catch exec, never expected to trigger"
send "catch exec\n"
expect {
  -re "Catchpoint \[0-9\]* .exec..*$gdb_prompt $"
          {pass $name}
  -re "Catch of exec not yet implemented.*$gdb_prompt $"
	  {pass $name}
  -re "$gdb_prompt $" {fail $name}
  timeout {fail "(timeout) $name"}
}

# Verify that "until <location>" works.  (This is really just syntactic
# sugar for "tbreak <location>; continue".)
#
send "until 79\n"
expect {
  -re "main .* at .*:79.*$gdb_prompt $"\
          {pass "until 79"}
  -re "$gdb_prompt $"\
          {fail "until 79"}
  timeout {fail "(timeout) until 79"}
}

# Verify that a malformed "until" is gracefully caught.
#
send "until 80 then stop\n"
expect {
  -re "Junk at end of arguments..*$gdb_prompt $"\
          {pass "malformed until"}
  -re "$gdb_prompt $"\
          {fail "malformed until"}
  timeout {fail "(timeout) malformed until"}
}

# Verify that GDB responds gracefully when asked to set a breakpoint
# on a nonexistent source line.
#
send "break 999\n"
expect {
  -re "No line 999 in file .*$gdb_prompt $"\
          {pass "break on non-existent source line"}
  -re "$gdb_prompt $"\
          {fail "break on non-existent source line"}
  timeout {fail "(timeout) break on non-existent source line"}
}

# Verify that GDB allows one to just say "break", which is treated
# as the "default" breakpoint.  Note that GDB gets cute when printing
# the informational message about other breakpoints at the same
# location.  We'll hit that bird with this stone too.
#
send "break\n"
expect {
  -re "Breakpoint \[0-9\]*.*$gdb_prompt $"\
          {pass "break on default location, 1st time"}
  -re "$gdb_prompt $"\
          {fail "break on default location, 1st time"}
  timeout {fail "(timeout) break on default location, 1st time"}
}

send "break\n"
expect {
  -re "Note: breakpoint \[0-9\]* also set at .*Breakpoint \[0-9\]*.*$gdb_prompt $"\
          {pass "break on default location, 2nd time"}
  -re "$gdb_prompt $"\
          {fail "break on default location, 2nd time"}
  timeout {fail "(timeout) break on default location, 2nd time"}
}

send "break\n"
expect {
  -re "Note: breakpoints \[0-9\]* and \[0-9\]* also set at .*Breakpoint \[0-9\]*.*$gdb_prompt $"\
          {pass "break on default location, 3rd time"}
  -re "$gdb_prompt $"\
          {fail "break on default location, 3rd time"}
  timeout {fail "(timeout) break on default location, 3rd time"}
}

send "break\n"
expect {
  -re "Note: breakpoints \[0-9\]*, \[0-9\]* and \[0-9\]* also set at .*Breakpoint \[0-9\]*.*$gdb_prompt $"\
          {pass "break on default location, 4th time"}
  -re "$gdb_prompt $"\
          {fail "break on default location, 4th time"}
  timeout {fail "(timeout) break on default location, 4th time"}
}

# Verify that a "silent" breakpoint can be set, and that GDB is indeed
# "silent" about its triggering.
#
if ![runto main] then { fail "break tests suppressed" }
expect {
        -re "$gdb_prompt $" { pass "run to main\n" }
        timeout {fail "run to main\n" }
        }

send "break 79\n"
expect {
  -re "Breakpoint (\[0-9\]*) at .*, line 79.*$gdb_prompt $"\
          {pass "set to-be-silent break 79"}
  -re "$gdb_prompt $"\
          {fail "set to-be-silent break 79"}
  timeout {fail "(timeout) set to-be-silent break 79"}
}

send "commands $expect_out(1,string)\n"
send "silent\n"
send "end\n"
expect {
  -re ".*$gdb_prompt $"\
          {pass "set silent break 79"}
  timeout {fail "(timeout) set silent break 79"}
}

send "info break $expect_out(1,string)\n"
expect {
  -re "\[0-9\]*\[ \t\]*breakpoint.*:79\r\n\[ \t\]*silent.*$gdb_prompt $"\
          {pass "info silent break 79"}
  -re "$gdb_prompt $"\
          {fail "info silent break 79"}
  timeout {fail "(timeout) info silent break 79"}
}
send "continue\n"
expect {
  -re "Continuing.\r\n$gdb_prompt $"\
          {pass "hit silent break 79"}
  -re "$gdb_prompt $"\
          {fail "hit silent break 79"}
  timeout {fail "(timeout) hit silent break 79"}
}
send "bt\n"
expect {
  -re "#0  main .* at .*:79.*$gdb_prompt $"\
          {pass "stopped for silent break 79"}
  -re "$gdb_prompt $"\
          {fail "stopped for silent break 79"}
  timeout {fail "(timeout) stopped for silent break 79"}
}

# Verify that GDB can at least parse a breakpoint with the
# "thread" keyword.  (We won't attempt to test here that a
# thread-specific breakpoint really triggers appropriately.
# The gdb.threads subdirectory contains tests for that.)
#
send "break 80 thread 999\n"
expect {
  -re "Unknown thread 999.*$gdb_prompt $"\
          {pass "thread-specific breakpoint on non-existent thread disallowed"}
  -re "$gdb_prompt $"\
          {fail "thread-specific breakpoint on non-existent thread disallowed"}
  timeout {fail "(timeout) thread-specific breakpoint on non-existent thread disallowed"}
}
send "break 80 thread foo\n"
expect {
  -re "Junk after thread keyword..*$gdb_prompt $"\
          {pass "thread-specific breakpoint on bogus thread ID disallowed"}
  -re "$gdb_prompt $"\
          {fail "thread-specific breakpoint on bogus thread ID disallowed"}
  timeout {fail "(timeout) thread-specific breakpoint on bogus thread ID disallowed"}
}

# Verify that GDB responds gracefully to a breakpoint command with
# trailing garbage.
#
send "break 80 foo\n"
expect {
  -re "Junk at end of arguments..*$gdb_prompt $"\
          {pass "breakpoint with trailing garbage disallowed"}
  -re "$gdb_prompt $"\
          {fail "breakpoint with trailing garbage disallowed"}
  timeout {fail "(timeout) breakpoint with trailing garbage disallowed"}
}

# Verify that GDB responds gracefully to a "clear" command that has
# no matching breakpoint.  (First, get us off the current source line,
# which we know has a breakpoint.)
#
send "next\n"
expect {
  -re ".*$gdb_prompt $"\
          {pass "step over breakpoint"}
  timeout {fail "(timeout) step over breakpoint"}
}
send "clear 81\n"
expect {
  -re "No breakpoint at 81..*$gdb_prompt $"\
          {pass "clear line has no breakpoint disallowed"}
  -re "$gdb_prompt $"\
          {fail "clear line has no breakpoint disallowed"}
  timeout {fail "(timeout) clear line has no breakpoint disallowed"}
}
send "clear\n"
expect {
  -re "No breakpoint at this line..*$gdb_prompt $"\
          {pass "clear current line has no breakpoint disallowed"}
  -re "$gdb_prompt $"\
          {fail "clear current line has no breakpoint disallowed"}
  timeout {fail "(timeout) clear current line has no breakpoint disallowed"}
}

# Verify that we can set and clear multiple breakpoints.
#
# We don't test that it deletes the correct breakpoints.  We do at
# least test that it deletes more than one breakpoint.
#
gdb_test "break marker3" "Breakpoint.*at.*" "break marker3 #1"
gdb_test "break marker3" "Breakpoint.*at.*" "break marker3 #2"
gdb_test "clear marker3" {Deleted breakpoints [0-9]+ [0-9]+.*}

# Verify that a breakpoint can be set via a convenience variable.
#
send "set \$foo=81\n"
expect {
  -re "$gdb_prompt $"\
          {pass "set convenience variable \$foo to 81"}
  timeout {fail "(timeout) set convenience variable \$foo to 81"}
}
send "break \$foo\n"
expect {
  -re "Breakpoint (\[0-9\]*) at .*, line 81.*$gdb_prompt $"\
          {pass "set breakpoint via convenience variable"}
  -re "$gdb_prompt $"\
          {fail "set breakpoint via convenience variable"}
  timeout {fail "(timeout) set breakpoint via convenience variable"}
}

# Verify that GDB responds gracefully to an attempt to set a
# breakpoint via a convenience variable whose type is not integer.
#
send "set \$foo=81.5\n"
expect {
  -re "$gdb_prompt $"\
          {pass "set convenience variable \$foo to 81.5"}
  timeout {fail "(timeout) set convenience variable \$foo to 81.5"}
}
send "break \$foo\n"
expect {
  -re "Convenience variables used in line specs must have integer values..*$gdb_prompt $"\
          {pass "set breakpoint via non-integer convenience variable disallowed"}
  -re "$gdb_prompt $"\
          {fail "set breakpoint via non-integer convenience variable disallowed"}
  timeout {fail "(timeout) set breakpoint via non-integer convenience variable disallowed"}
}

# Verify that we can set and trigger a breakpoint in a user-called function.
#
send "break marker2\n"
expect {
    -re "Breakpoint (\[0-9\]*) at .*, line 4\[49\].*$gdb_prompt $"\
          {pass "set breakpoint on to-be-called function"}
  -re "$gdb_prompt $"\
          {fail "set breakpoint on to-be-called function"}
  timeout {fail "(timeout) set breakpoint on to-be-called function"}
}
send "print marker2(99)\n"
expect {
  -re "The program being debugged stopped while in a function called from GDB.\r\nWhen the function .marker2$proto. is done executing, GDB will silently\r\nstop .instead of continuing to evaluate the expression containing\r\nthe function call...*$gdb_prompt $"\
          {pass "hit breakpoint on called function"}
  -re "$gdb_prompt $"\
          {fail "hit breakpoint on called function"}
  timeout {fail "(timeout) hit breakpoint on called function"}
}

# As long as we're stopped (breakpointed) in a called function,
# verify that we can successfully backtrace & such from here.
#
# In this and the following test, the _sr4export check apparently is needed
# for hppa*-*-hpux.
#
send "bt\n"
expect {
    -re "#0\[ \t\]*($hex in )?marker2.*:4\[49\]\r\n#1.*_sr4export.*$gdb_prompt $"\
            {pass "backtrace while in called function"}
    -re "#0\[ \t\]*($hex in )?marker2.*:4\[49\]\r\n#1.*function called from gdb.*$gdb_prompt $"\
	    {pass "backtrace while in called function"}
    -re "$gdb_prompt $"\
            {fail "backtrace while in called function"}
    timeout {fail "(timeout) backtrace while in called function"}
}

# Return from the called function.  For remote targets, it's important to do
# this before runto_main, which otherwise may silently stop on the dummy
# breakpoint inserted by GDB at the program's entry point.
#
send "finish\n"
expect {
    -re "Run till exit from .*marker2.* at .*4\[49\]\r\n.* in _sr4export.*$gdb_prompt $"\
            {pass "finish from called function"}
    -re "Run till exit from .*marker2.* at .*4\[49\]\r\n.*function called from gdb.*$gdb_prompt $"\
            {pass "finish from called function"}
    -re "Run till exit from .*marker2.* at .*4\[49\]\r\n.*Value returned.*$gdb_prompt $"\
            {pass "finish from called function"}
    -re "$gdb_prompt $"\
            {fail "finish from called function"}
    timeout {fail "(timeout) finish from called function"}
}

# Verify that GDB responds gracefully to a "finish" command with
# arguments.
#
if ![runto main] then { fail "break tests suppressed" }
expect {
        -re "$gdb_prompt $" { pass "run to main\n" }
        timeout {fail "run to main\n" }
        }


send "finish 123\n"
expect {
  -re "The \"finish\" command does not take any arguments.\r\n$gdb_prompt $"\
          {pass "finish with arguments disallowed"}
  -re "$gdb_prompt $"\
          {fail "finish with arguments disallowed"}
  timeout {fail "(timeout) finish with arguments disallowed"}
}

# Verify that GDB responds gracefully to a request to "finish" from
# the outermost frame.  On a stub that never exits, this will just
# run to the stubs routine, so we don't get this error...  Thus the 
# second condition.
#

send "finish\n"
expect {
  -re "\"finish\" not meaningful in the outermost frame.\r\n$gdb_prompt $"\
          {pass "finish from outermost frame disallowed"}
  -re "Run till exit from.*\r\n$gdb_prompt $" {
     pass "finish from outermost frame disallowed"
  }
  -re "$gdb_prompt $"\
          {fail "finish from outermost frame disallowed"}
  timeout {fail "(timeout) finish from outermost frame disallowed"}
}


#
# Test "next" over recursive function call.
#

proc test_next_with_recursion {} { 
    global gdb_prompt
    global decimal

	# FIXME: should be using runto
	send "kill \n"
	expect {
	 -re  "Kill the program being debugged.*y or n. $" { send "y\n" ;  pass "kill program" }
	timeout { fail "kill program" }
	}
	delete_breakpoints

    gdb_test "break factorial" "Breakpoint $decimal at .*" "break at factorial"

    # Run until we call factorial with 6

	gdb_run_cmd
    expect {
	-re "Break.* factorial .value=6. .*$gdb_prompt $" {}
	-re ".*$gdb_prompt $" {
	    fail "run to factorial(6)";
	}
	timeout { fail "run to factorial(6) (timeout)" ; gdb_suppress_tests }
    }

    # Continue until we call factorial recursively with 5.

    gdb_test "continue" \
	"Continuing.*Break.* factorial .value=5. .*" \
	"continue to factorial(5)"

    # Do a backtrace just to confirm how many levels deep we are.

    gdb_test "backtrace" \
	"#0\[ \t\]+ factorial .value=5..*" \
	"backtrace from factorial(5)"

    # Now a "next" should position us at the recursive call, which
    # we will be performing with 4.

    gdb_test "next" \
	".* factorial .value - 1.;.*" \
	"next to recursive call"

    # Disable the breakpoint at the entry to factorial by deleting them all.
    # The "next" should run until we return to the next line from this
    # recursive call to factorial with 4.
    # Buggy versions of gdb will stop instead at the innermost frame on
    # the line where we are trying to "next" to.

    delete_breakpoints

    # We used to set timeout here for all other targets as well.  This
    # is almost certainly wrong.  The proper timeout depends on the
    # target system in use, and how we communicate with it, so there
    # is no single value appropriate for all targets.  The timeout
    # should be established by the Dejagnu config file(s) for the
    # board, and respected by the test suite.
    #
    # For example, if I'm running GDB over an SSH tunnel talking to a
    # portmaster in California talking to an ancient 68k board running
    # a crummy ROM monitor (a situation I can only wish were
    # hypothetical), then I need a large timeout.  But that's not the
    # kind of knowledge that belongs in this file.

    gdb_test next "\[0-9\]*\[\t \]+return \\(value\\);.*" \
	    "next over recursive call"

    # OK, we should be back in the same stack frame we started from.
    # Do a backtrace just to confirm.

    gdb_test "backtrace" \
	    "#0\[ \t\]+ factorial .value=120.*\r\n#1\[ \t\]+ \[0-9a-fx\]+ in factorial .value=6..*" \
	    "backtrace from factorial(5.1)"

  gdb_continue_to_end "recursive next test"
}

test_next_with_recursion


#********


send "quit \r"
