/*
   b_char.cpp   Generated by the Ballista(tm) Project data object compiler
   Copyright (C) 1998-2001  Carnegie Mellon University

   This program is free software; you can redistribute it and/or
   modify it under the terms of the GNU General Public License
   as published by the Free Software Foundation; either version 2
   of the License, or (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

   File generated Friday, December 17 at 06:12 PM CST

TITLE
   b_char.cpp
*/

//--------------------------------------------------------------------

#include <errno.h>
#include <iostream.h>
#include <stdio.h>
#include <stdlib.h>
#include <stream.h>
#include <string.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>

#include "b_char.h"

//--------------------------------------------------------------------


 #define MaxBytes sizeof(unsigned short);
 //--------------------------------------------------------------------

CLASSNAME::CLASSNAME()
{
  //DIAL DECLARATIONS HERE

  //generated

   strcpy(_b_charTYPENAME,CLASS_STRING);
strcpy(_b_charNUL,"b_char_NUL");
strcpy(_b_charSOH,"b_char_SOH");
strcpy(_b_charTAB,"b_char_TAB");
strcpy(_b_charLF,"b_char_LF");
strcpy(_b_charCR,"b_char_CR");
strcpy(_b_charDLE,"b_char_DLE");
strcpy(_b_charESC,"b_char_ESC");
strcpy(_b_charSPACE,"b_char_SPACE");
strcpy(_b_charCOMMA,"b_char_COMMA");
strcpy(_b_charNUM0,"b_char_NUM0");
strcpy(_b_charNUM9,"b_char_NUM9");
strcpy(_b_charAT,"b_char_AT");
strcpy(_b_charBIGA,"b_char_BIGA");
strcpy(_b_charBIGZ,"b_char_BIGZ");
strcpy(_b_charLEFTSQBRKT,"b_char_LEFTSQBRKT");
strcpy(_b_charAPST,"b_char_APST");
strcpy(_b_charSMLA,"b_char_SMLA");
strcpy(_b_charSMLZ,"b_char_SMLZ");
strcpy(_b_charLEFTCUVBRKT,"b_char_LEFTCUVBRKT");
strcpy(_b_charFF,"b_char_FF");
}

//--------------------------------------------------------------------
b_param *b_char::b_charNUL()
{
   return &_b_charNUL;
}

b_param *b_char::b_charSOH()
{
   return &_b_charSOH;
}

b_param *b_char::b_charTAB()
{
   return &_b_charTAB;
}

b_param *b_char::b_charLF()
{
   return &_b_charLF;
}

b_param *b_char::b_charCR()
{
   return &_b_charCR;
}

b_param *b_char::b_charDLE()
{
   return &_b_charDLE;
}

b_param *b_char::b_charESC()
{
   return &_b_charESC;
}

b_param *b_char::b_charSPACE()
{
   return &_b_charSPACE;
}

b_param *b_char::b_charCOMMA()
{
   return &_b_charCOMMA;
}

b_param *b_char::b_charNUM0()
{
   return &_b_charNUM0;
}

b_param *b_char::b_charNUM9()
{
   return &_b_charNUM9;
}

b_param *b_char::b_charAT()
{
   return &_b_charAT;
}

b_param *b_char::b_charBIGA()
{
   return &_b_charBIGA;
}

b_param *b_char::b_charBIGZ()
{
   return &_b_charBIGZ;
}

b_param *b_char::b_charLEFTSQBRKT()
{
   return &_b_charLEFTSQBRKT;
}

b_param *b_char::b_charAPST()
{
   return &_b_charAPST;
}

b_param *b_char::b_charSMLA()
{
   return &_b_charSMLA;
}

b_param *b_char::b_charSMLZ()
{
   return &_b_charSMLZ;
}

b_param *b_char::b_charLEFTCUVBRKT()
{
   return &_b_charLEFTCUVBRKT;
}

b_param *b_char::b_charFF()
{
   return &_b_charFF;
}

//--------------------------------------------------------------------
//---------------------------------------------------------------------------
//type name return method

b_param *CLASSNAME::typeName()
{
  return &_b_charTYPENAME;
}

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
int CLASSNAME::distanceFromBase()
{
  return CLASSPARENT::distanceFromBase() +1;
}


//---------------------------------------------------------------------------
void CLASSNAME::typeList(b_param list[], int num)
{
  strcpy(list[num],(char *) typeName());
  CLASSPARENT::typeList(list,num+1);
}
//--------------------------------------------------------------------
  void *CLASSNAME::access(b_param data[])
{
  if (strcmp(data[0],(char *)typeName())!=0)
    return CLASSPARENT::access(data);

  //ACCESS CODE
b_char_nul = 0;
b_char_soh = 0;
b_char_tab = 0;
b_char_lf = 0;
b_char_cr = 0;
b_char_dle = 0;
b_char_esc = 0;
b_char_space = 0;
b_char_comma = 0;
b_char_num0 = 0;
b_char_num9 = 0;
b_char_at = 0;
b_char_biga = 0;
b_char_bigz = 0;
b_char_leftsqbrkt = 0;
b_char_apst = 0;
b_char_smla = 0;
b_char_smlz = 0;
b_char_leftcuvbrkt = 0;
b_char_ff = 0;
   int dataPTR =0;


   dataPTR++;
if (strcmp(data[dataPTR],_b_charNUL)==0)
      b_char_nul = 1;
   else if (strcmp(data[dataPTR],_b_charSOH)==0)
      b_char_soh = 1;
   else if (strcmp(data[dataPTR],_b_charTAB)==0)
      b_char_tab = 1;
   else if (strcmp(data[dataPTR],_b_charLF)==0)
      b_char_lf = 1;
   else if (strcmp(data[dataPTR],_b_charCR)==0)
      b_char_cr = 1;
   else if (strcmp(data[dataPTR],_b_charDLE)==0)
      b_char_dle = 1;
   else if (strcmp(data[dataPTR],_b_charESC)==0)
      b_char_esc = 1;
   else if (strcmp(data[dataPTR],_b_charSPACE)==0)
      b_char_space = 1;
   else if (strcmp(data[dataPTR],_b_charCOMMA)==0)
      b_char_comma = 1;
   else if (strcmp(data[dataPTR],_b_charNUM0)==0)
      b_char_num0 = 1;
   else if (strcmp(data[dataPTR],_b_charNUM9)==0)
      b_char_num9 = 1;
   else if (strcmp(data[dataPTR],_b_charAT)==0)
      b_char_at = 1;
   else if (strcmp(data[dataPTR],_b_charBIGA)==0)
      b_char_biga = 1;
   else if (strcmp(data[dataPTR],_b_charBIGZ)==0)
      b_char_bigz = 1;
   else if (strcmp(data[dataPTR],_b_charLEFTSQBRKT)==0)
      b_char_leftsqbrkt = 1;
   else if (strcmp(data[dataPTR],_b_charAPST)==0)
      b_char_apst = 1;
   else if (strcmp(data[dataPTR],_b_charSMLA)==0)
      b_char_smla = 1;
   else if (strcmp(data[dataPTR],_b_charSMLZ)==0)
      b_char_smlz = 1;
   else if (strcmp(data[dataPTR],_b_charLEFTCUVBRKT)==0)
      b_char_leftcuvbrkt = 1;
   else if (strcmp(data[dataPTR],_b_charFF)==0)
      b_char_ff = 1;
  else
    {
      cerr<<"Error: Unknown setting for the "
          <<"HVAL"
          <<" dial of the data object "
          <<CLASS_STRING
          <<". "<<endl
          <<"The offending string is : "
          <<data[dataPTR]
          <<endl;
      exit(1);
    }

if (b_char_nul==1)
{

 _theVariable=0;
 
}

if (b_char_soh==1)
{

 _theVariable=1;
 
}

if (b_char_tab==1)
{

 _theVariable=9;
 
}

if (b_char_lf==1)
{

 _theVariable=10;
 
}

if (b_char_cr==1)
{

 _theVariable=13;
 
}

if (b_char_dle==1)
{

 _theVariable=16;
 
}

if (b_char_esc==1)
{

 _theVariable=27;
 
}

if (b_char_space==1)
{

 _theVariable=32;
 
}

if (b_char_comma==1)
{

 _theVariable=44;
 
}

if (b_char_num0==1)
{

 _theVariable=48; 
 
}

if (b_char_num9==1)
{

 _theVariable=57;
 
}

if (b_char_at==1)
{

 _theVariable=64; 
 
}

if (b_char_biga==1)
{

 _theVariable=65;
 
}

if (b_char_bigz==1)
{

 _theVariable=90;
 
}

if (b_char_leftsqbrkt==1)
{

 _theVariable=91;
 
}

if (b_char_apst==1)
{

 _theVariable=96;
 
}

if (b_char_smla==1)
{

 _theVariable=97;
 
}

if (b_char_smlz==1)
{

 _theVariable=122;
 
}

if (b_char_leftcuvbrkt==1)
{

 _theVariable=123;
 
}

if (b_char_ff==1)
{

 _theVariable=255;
 
}
   return &_theVariable;
}

//--------------------------------------------------------------------
  int CLASSNAME::commit(b_param tname)
{
  if (strcmp(tname,(char *)typeName())!=0)
    return CLASSPARENT::commit(tname);
  //COMMIT CODE HERE
//generated

#ifdef DEBUG
 printf("VALUE:%c in commit\n", _theVariable);
#endif
   return 0;
}

//--------------------------------------------------------------------
  int CLASSNAME::cleanup(b_param tname)
{
  if (strcmp(tname,(char *)typeName())!=0)
    return CLASSPARENT::cleanup(tname);
      
  //CLEANUP CODE
//generated

#ifdef DEBUG
 printf("VALUE:%c in cleanup\n", _theVariable);
#endif
   return 0;
}

//--------------------------------------------------------------------
int CLASSNAME::numDials(b_param tname)
{
  if (!strcmp(tname,(char *)typeName()))
    return NUMBER_OF_DIALS;
  else return CLASSPARENT::numDials(tname);
      
}


//---------------------------------------------------------------------------
int CLASSNAME::numItems(b_param tname,int dialNumber)
{
  if (strcmp(tname,(char *)typeName())!=0)
    return CLASSPARENT::numItems(tname,dialNumber);
  switch (dialNumber)
    {
      //NUMITEMS SWITCH CASES HERE
      //generated

   case 1:
      return 20;
      break;
//---------------------------------------------------------------------------
      //end generated

    default:
      cerr<<"Error, invalid dial number passed to "
          <<CLASS_STRING<<"::numItems\n"
          <<"Please check declaration files.  Dial number passed was "
          <<dialNumber<<endl;
      exit(1);
    }
  return 0;
}

//---------------------------------------------------------------------------
b_param *CLASSNAME::paramName(b_param tname,
                                   int dialNumber,
                                   int position)

{
  if (strcmp(tname,(char *)typeName())!=0)
    return CLASSPARENT::paramName(tname,dialNumber,position);
  
  switch (dialNumber)
    {
      //PARAMNAME SWITCH CASES HERE
      //generated

case 1:
 switch (position)
   {
      case 1:
         return b_charNUL();
         break;
      case 2:
         return b_charSOH();
         break;
      case 3:
         return b_charTAB();
         break;
      case 4:
         return b_charLF();
         break;
      case 5:
         return b_charCR();
         break;
      case 6:
         return b_charDLE();
         break;
      case 7:
         return b_charESC();
         break;
      case 8:
         return b_charSPACE();
         break;
      case 9:
         return b_charCOMMA();
         break;
      case 10:
         return b_charNUM0();
         break;
      case 11:
         return b_charNUM9();
         break;
      case 12:
         return b_charAT();
         break;
      case 13:
         return b_charBIGA();
         break;
      case 14:
         return b_charBIGZ();
         break;
      case 15:
         return b_charLEFTSQBRKT();
         break;
      case 16:
         return b_charAPST();
         break;
      case 17:
         return b_charSMLA();
         break;
      case 18:
         return b_charSMLZ();
         break;
      case 19:
         return b_charLEFTCUVBRKT();
         break;
      case 20:
         return b_charFF();
         break;

      default:
          cerr<<"Error, invalid position number passed to "
              <<CLASS_STRING<<"::paramName\n"
              <<"Please check declaration files.  Dial number passed was"
              <<dialNumber<<" position "<<position<<".\n";
          exit(1);
   }
   break;
    default:
      cerr<<"Error, invalid dial number passed to "
          <<CLASS_STRING<<"::paramName\n"
          <<"Please check declaration files.  Dial number passed was "
          <<dialNumber<<endl;
      exit(1);

    }
  return NULL;
}

//---------------------------------------------------------------------------
