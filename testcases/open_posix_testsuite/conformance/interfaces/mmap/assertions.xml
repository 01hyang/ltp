<assertions>
  <assertion id="1" tag="ref:XSH6:25180:25190">
25180 The mmap( ) function shall establish a mapping between a process¡¯ address space and a file,
25181 TYM shared memory object, or typed memory object. The format of the call is as follows:
25182 pa=mmap(addr, len, prot, flags, fildes, off);
25183 The mmap( ) function shall establish a mapping between the address space of the process at an
25184 address pa for len bytes to the memory object represented by the file descriptor fildes at offset off
25185 for len bytes. The value of pa is an implementation-defined function of the parameter addr and
25186 the values of flags , further described below. A successful mmap( ) call shall return pa as its result.
25187 The address range starting at pa and continuing for len bytes shall be legitimate for the possible
25188 (not necessarily current) address space of the process. The range of bytes starting at off and
25189 continuing for len bytes shall be legitimate for the possible (not necessarily current) offsets in the
25190 TYM file, shared memory object, or typed memory object represented by fildes.
  </assertion>
  
  <assertion id="2" tag="ref:XSH6:25191:25196">
25191 TYM If fildes represents a typed memory object opened with either the
25192 POSIX_TYPED_MEM_ALLOCATE flag or the POSIX_TYPED_MEM_ALLOCATE_CONTIG
25193 flag, the memory object to be mapped shall be that portion of the typed memory object allocated
25194 by the implementation as specified below. In this case, if off is non-zero, the behavior of mmap( )
25195 is undefined. If fildes refers to a valid typed memory object that is not accessible from the calling
25196 process, mmap( ) shall fail.
  </assertion>

  <assertion id="3" tag="ref:XSH6:25197:25199">
25197 The mapping established by mmap( ) shall replace any previous mappings for those whole pages
25198 containing any part of the address space of the process starting at pa and continuing for len
25199 bytes.
  </assertion>

  <assertion id="4" tag="ref:XSH6:25203:25204">
25203 TYM The mmap( ) function shall be supported for regular files, shared memory objects, and typed
25204 memory objects. Support for any other type of file is unspecified.
  </assertion>
  
  
<assertion id="5" tag="ref:XSH6:25206:25216">
25206 The prot shall be either PROT_NONE or the bitwise-
25207 inclusive OR of one or more of the other flags in the following table, defined in the
25208 <sys/mman.h> header.
25211 PROT_READ Data can be read.
25212 PROT_WRITE Data can be written.
25213 PROT_EXEC Data can be executed.
25214 PROT_NONE Data cannot be accessed. 
25215 If an implementation cannot support the combination of access types specified by prot, the call
25216 to mmap( ) shall fail.
</assertion>
  
    <assertion id="6" tag="ref:XSH6:25217:25226">
25217 MPR An implementation may permit accesses other than those specified by prot; however, if the
25218 Memory Protection option is supported, the implementation shall not permit a write to succeed
25219 where PROT_WRITE has not been set or shall not permit any access where PROT_NONE alone
25220 has been set. The implementation shall support at least the following values of prot:
25221 PROT_NONE, PROT_READ, PROT_WRITE, and the bitwise-inclusive OR of PROT_READ and
25222 PROT_WRITE. If the Memory Protection option is not supported, the result of any access that
25223 conflicts with the specified protection is undefined. The file descriptor fildes shall have been
25224 opened with read permission, regardless of the protection options specified. If PROT_WRITE is
25225 specified, the application shall ensure that it has opened the file descriptor fildes with write
25226 permission unless MAP_PRIVATE is specified in the flags parameter as described below.
  </assertion>
  
    <assertion id="7" tag="ref:XSH6:25236:25244">
25236 XSI It is implementation-defined whether MAP_FIXED shall be supported. MAP_FIXED shall be
25237 supported on XSI-conformant systems.
25238 MAP_SHARED and MAP_PRIVATE describe the disposition of write references to the memory
25239 object. If MAP_SHARED is specified, write references shall change the underlying object. If
25240 MAP_PRIVATE is specified, modifications to the mapped data by the calling process shall be
25241 visible only to the calling process and shall not change the underlying object. It is unspecified
25242 whether modifications to the underlying object done after the MAP_PRIVATE mapping is
25243 established are visible through the MAP_PRIVATE mapping. Either MAP_SHARED or
25244 MAP_PRIVATE can be specified, but not both. The mapping type is retained across fork( ).
  </assertion>
  
    <assertion id="8" tag="ref:XSH6:25245:25260">
25245 TYM When fildes represents a typed memory object opened with either the
25246 POSIX_TYPED_MEM_ALLOCATE flag or the POSIX_TYPED_MEM_ALLOCATE_CONTIG
25247 flag, mmap( ) shall, if there are enough resources available, map len bytes allocated from the
25248 corresponding typed memory object which were not previously allocated to any process in any
25249 processor that may access that typed memory object. If there are not enough resources available,
25250 the function shall fail. If fildes represents a typed memory object opened with the
25251 POSIX_TYPED_MEM_ALLOCATE_CONTIG flag, these allocated bytes shall be contiguous
25252 within the typed memory object. If fildes represents a typed memory object opened with the
25253 POSIX_TYPED_MEM_ALLOCATE flag, these allocated bytes may be composed of non-
25254 contiguous fragments within the typed memory object. If fildes represents a typed memory
25255 object opened with neither the POSIX_TYPED_MEM_ALLOCATE_CONTIG flag nor the
25256 POSIX_TYPED_MEM_ALLOCATE flag, len bytes starting at offset off within the typed memory
25257 object are mapped, exactly as when mapping a file or shared memory object. In this case, if two
25258 processes map an area of typed memory using the same off and len values and using file
25259 descriptors that refer to the same memory pool (either from the same port or from a different
25260 port), both processes shall map the same region of storage.
  </assertion>
  
    <assertion id="9" tag="ref:XSH6:25261:25264">
25261 When MAP_FIXED is set in the flags argument, the implementation is informed that the value of
25262 pa shall be addr, exactly. If MAP_FIXED is set, mmap( ) may returnMAP_FAILED and set errno to
25263 [EINVAL]. If a MAP_FIXED request is successful, the mapping established by mmap( ) replaces
25264 any previous mappings for the process¡¯ pages in the range [pa,pa+len).
  </assertion>
  
    <assertion id="10" tag="ref:XSH6:25265:25271">
25265 When MAP_FIXED is not set, the implementation uses addr in an implementation-defined
25266 manner to arrive at pa. The pa so chosen shall be an area of the address space that the
25267 implementation deems suitable for a mapping of len bytes to the file. All implementations
25268 interpret an addr value of 0 as granting the implementation complete freedom in selecting pa,
25269 subject to constraints described below. A non-zero value of addr is taken to be a suggestion of a
25270 process address near which the mapping should be placed. When the implementation selects a
25271 value for pa, it never places a mapping at address 0, nor does it replace any extant mapping.
  </assertion>
  
    <assertion id="11" tag="ref:XSH6:25272:25281">
25272 The off argument is constrained to be aligned and sized according to the value returned by
25273 sysconf( ) when passed _SC_PAGESIZE or _SC_PAGE_SIZE. When MAP_FIXED is specified, the
25274 application shall ensure that the argument addr also meets these constraints. The
25275 implementation performs mapping operations over whole pages. Thus, while the argument len
25276 need not meet a size or alignment constraint, the implementation shall include, in any mapping
25277 operation, any partial page specified by the range [pa,pa+len).
25278 The system shall always zero-fill any partial page at the end of an object. Further, the system
25279 shall never write out any modified portions of the last page of an object which are beyond its
25280 MPR end. References within the address range starting at pa and continuing for len bytes to whole
25281 pages following the end of an object shall result in delivery of a SIGBUS signal.
  </assertion>
  
    <assertion id="12" tag="ref:XSH6:25284:25286">
25284 The mmap( ) function shall add an extra reference to the file associated with the file descriptor
25285 fildes which is not removed by a subsequent close( ) on that file descriptor. This reference shall be
25286 removed when there are no more mappings to the file.
  </assertion>
  
      <assertion id="13" tag="ref:XSH6:25287:25290">
25287 The st_atime field of the mapped file may be marked for update at any time between the mmap( )
25288 call and the corresponding munmap( ) call. The initial read or write reference to a mapped region
25289 shall cause the file¡¯s st_atime field to be marked for update if it has not already been marked for
25290 update.
  </assertion>
  
      <assertion id="14" tag="ref:XSH6:25291:25296">
25291 The st_ctime and st_mtime fields of a file that is mapped with MAP_SHARED and PROT_WRITE
25292 shall be marked for update at some point in the interval between a write reference to the
25293 mapped region and the next call to msync( ) with MS_ASYNC or MS_SYNC for that portion of
25294 the file by any process. If there is no such call and if the underlying file is modified as a result of
25295 a write reference, then these fields shall be marked for update at some time after the write
25296 reference.
  </assertion>
  
      <assertion id="15" tag="ref:XSH6:25301:25303">
25301 If mmap( ) fails for reasons other than [EBADF], [EINVAL], or [ENOTSUP], some of the
25302 mappings in the address range starting at addr and continuing for len bytes may have been
25303 unmapped.
  </assertion>

  
      <assertion id="16" tag="ref:XSH6:25305:25308">
25305 Upon successful completion, the mmap( ) function shall return the address at which the mapping
25306 was placed (pa); otherwise, it shall return a value of MAP_FAILED and set errno to indicate the
25307 error. The symbol MAP_FAILED is defined in the <sys/mman.h> header. No successful return
25308 from mmap( ) shall return the value MAP_FAILED.
      </assertion>
  
      <assertion id="17" tag="ref:XSH6:25310:25342">
25310 The mmap( ) function shall fail if:
25311 [EACCES] The fildes argument is not open for read, regardless of the protection specified,
25312 or fildes is not open for write and PROT_WRITE was specified for a
25313 MAP_SHARED type mapping.
	  </assertion>
      
      <assertion id="18" tag="ref:XSH6:25310:25315">
25310 The mmap( ) function shall fail if:
25314 ML [EAGAIN] The mapping could not be locked in memory, if required by mlockall ( ), due to
25315 a lack of resources.
      </assertion>
      
      <assertion id="19" tag="ref:XSH6:25310:25342">
25310 The mmap( ) function shall fail if:
25316 [EBADF] The fildes argument is not a valid open file descriptor.
      </assertion>
      
      <assertion id="20" tag="ref:XSH6:25310:25342">
25310 The mmap( ) function shall fail if:
25317 [EINVAL] The addr argument (if MAP_FIXED was specified) or off is not a multiple of
25318 the page size as returned by sysconf( ), or is considered invalid by the
25319 implementation.
      </assertion>

      <assertion id="21" tag="ref:XSH6:25310:25342">
25310 The mmap( ) function shall fail if:
25320 [EINVAL] The value of flags is invalid (neither MAP_PRIVATE nor MAP_SHARED is
25321 set).
      </assertion>

      <assertion id="22" tag="ref:XSH6:25310:25342">
25310 The mmap( ) function shall fail if:
25322 [EMFILE] The number of mapped regions would exceed an implementation-defined
25323 limit (per process or per system).
      </assertion>

      <assertion id="23" tag="ref:XSH6:25310:25342">
25310 The mmap( ) function shall fail if:
25324 [ENODEV] The fildes argument refers to a file whose type is not supported by mmap( ).
	  </assertion>

      <assertion id="24" tag="ref:XSH6:25310:25342">
25310 The mmap( ) function shall fail if:
25325 [ENOMEM] MAP_FIXED was specified, and the range [addr,addr+len) exceeds that allowed
25326 for the address space of a process; or, if MAP_FIXED was not specified and
25327 there is insufficient room in the address space to effect the mapping.
      </assertion>

      <assertion id="25" tag="ref:XSH6:25310:25342">
25310 The mmap( ) function shall fail if:
25328 ML [ENOMEM] The mapping could not be locked in memory, if required by mlockall ( ),
25329 because it would require more space than the system is able to supply.
      </assertion>
      
      <assertion id="26" tag="ref:XSH6:25310:25342">
25310 The mmap( ) function shall fail if:
25330 TYM [ENOMEM] Not enough unallocated memory resources remain in the typed memory
25331 object designated by fildes to allocate len bytes.
      </assertion>

      <assertion id="27" tag="ref:XSH6:25310:25342">
25310 The mmap( ) function shall fail if:
25332 [ENOTSUP] MAP_FIXED or MAP_PRIVATE was specified in the flags argument and the
25333 implementation does not support this functionality.
25334 The implementation does not support the combination of accesses requested
25335 in the prot argument.
     </assertion>

      <assertion id="28" tag="ref:XSH6:25310:25342">
25310 The mmap( ) function shall fail if:
25336 [ENXIO] Addresses in the range [off,off+len) are invalid for the object specified by fildes.
      </assertion>
     
      <assertion id="29" tag="ref:XSH6:25310:25342">
25310 The mmap( ) function shall fail if:
25337 [ENXIO] MAP_FIXED was specified in flags and the combination of addr, len, and off is
25338 invalid for the object specified by fildes.
	  </assertion>

      <assertion id="30" tag="ref:XSH6:25310:25342">
25310 The mmap( ) function shall fail if:
25339 TYM [ENXIO] The fildes argument refers to a typed memory object that is not accessible from
25340 the calling process.
      </assertion>
      
      <assertion id="31" tag="ref:XSH6:25310:25342">
25310 The mmap( ) function shall fail if:
25341 [EOVERFLOW] The file is a regular file and the value of off plus len exceeds the offset
25342 maximum established in the open file description associated with fildes.
      </assertion>
</assertions>

