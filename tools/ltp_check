#!/usr/bin/perl
 
#LTP results gathering script: ltp_check
#       3/12/02 William Jay Huie (creation)
#       3/28/02 William Jay Huie minor fixes, increased results parsing
#This will log into the LTP_HOST machine, which may be different then the 
#machine used to run the ltp_master script
#This script will check for *ltpoutput.tgz files created by the ltprun script
#and download them each to their own directory and do a bit of processing
#the results gathering probably needs to be extended but hopefully this is a good
#first go at it

use Net::FTP ();

#CHANGEME:
#For some reason doesn't work if you do ~/ltp/results, so you need to code the
#explicit path for LTP_RES_DIR unless someone can tell me why
$LTP_RES_DIR="/home/wjhuie/ltp/results";
#CHANGEME:
$LTP_HOST="ltp_host.somewhere.org";
$LTP_USER="ltp";
$LTP_PASS="ltp";
$LTP_LOGFILE="ltp-logfile";
$LTP_RUN_OUTPUT="ltprun.out";
$LTP_RUNALL_OUT="runall.output";
$RESULTS_OUT="results.out";

@res_dirs;
$count = 0;
$RES = 0;

sub download_results()
{
   print "Attempting to download the LTP results\n";

   $dir = system("ls $LTP_RES_DIR &> /dev/null") / 256;
   if ($dir)
   {
     print "Making a results directory in $LTP_RES_DIR\n";
     `mkdir -p $LTP_RES_DIR`;
     chdir "$LTP_RES_DIR" or die "Can't change to $LTP_RES_DIR\n";
   }
   else
   { chdir "$LTP_RES_DIR" or die "Can't change to $LTP_RES_DIR\n"; }

   $ftp = Net::FTP->new($LTP_HOST, Debug => 0) or die "Can't connect to ftp: $LTP_HOST";
   $ftp->login($LTP_USER, $LTP_PASS) or die "Unable to login";
   $ftp->type('I') or die "Unable to set type to Binary";
   @files = $ftp->ls("*ltpoutput.tgz");
   $num_files = $#files + 1;
   print "New results files found $num_files:\n"; 
   for ($i = 0; $i < $num_files; $i++) { print "\t$files[$i]\n"; }
   
   for ($i = 0; $i < $num_files; $i++)
   {
      print "Downloading: $files[$i]\t";
      if ($ftp->get($files[$i]))
      { 
         print "Successful\n"; 
        $ftp->delete($files[$i]);
      }
      else
      { print "FAILED\n"; }
      
   }
   $ftp->quit;

   @res = `ls $LTP_RES_DIR/*.tgz 2> /dev/null`;

   if (@res)
   {
      $num = $#res + 1;
      print "             download of LTP results finished\n"; 
      print "$num unprocessed results files found\n";
      chomp(@res);
      return 1;
   }
   else
   {  print "             no apparent results to process\n"; return 0; }
 
}

sub untar_results()
{
   for ($i = 0; $i < $num; $i++)
   {
      if ( $res[$i] =~ m/\s*(\w+)-((\w+)-)*ltpoutput.tgz/ )
      {
         $hostname = $1; 
         $epoch_time = $3; 
         $english_time = localtime($epoch_time);
         $dir = "$LTP_RES_DIR/$hostname/$english_time";

         if ($english_time)
         {
            $new_dir = $dir;
            $new_dir =~ s/ /_/g;
            print "New results: $hostname @ $english_time\n";
            `mkdir -p '$new_dir'`;
            chdir "$new_dir" or die "Can't change to $new_dir\n";
            `tar -zxf $res[$i]`;
            `mv $res[$i] $new_dir`;
            $res_dirs[$count] = $new_dir; $count++;
         }
         else
         { 
            print "No timestamp on results file, skipping for now\n";
#Should come up with a soultion for this, check/create $hostname
#     then some unique identifier but for now we'll complain and ignore
         }
      }
   }
   return 1;
}

sub gather_results()
{
   print "Gathering $count result(s):\n";

   for ($i = 0; $i < $count; $i++)
   {
      print "\nResults for: $res_dirs[$i]\n";
      chdir "$res_dirs[$i]" or die "Can't change to $res_dirs[$i]\n";

      chomp($stat = `tail -n1 $LTP_RUNALL_OUT`);
      print "\t\t$stat\n";

      $num_success = `grep "stat=0" $LTP_LOGFILE | wc -l`;
      if ( $num_success =~ /\s*(\d+)\s*/ ) { $num_success = $1; }

      @fails = `grep "stat=" $LTP_LOGFILE | grep -v "stat=0"`;
      $num_fail = $#fails + 1;

      $pass_percent = sprintf("%.2f", 
                         ($num_success / ($num_success + $num_fail)) * 100);

      $ltp_ver = `grep "version" $LTP_RUN_OUTPUT`;
      if ( $ltp_ver =~ m/.*version: (.*)/ ) { $ltp_ver = $1; }

      $line = "Pass $pass_percent % : $num_success succeeded : $num_fail failed";
      print "$line";

      if (open RES, ">$RESULTS_OUT")
      {
         print ". -> Results stored in $RESULTS_OUT\n";
         $num = 
#The <<test_start>> doesn't seem to always get into the runalltest.sh output capture
#So for now relying on the last thing in the ver_linux script to tell us when to stop copying
#          system("awk '/<<test_start>>/ { exit NR-1; }' $LTP_RUNALL_OUT") / 256;
           system("awk '/bogomips/ { exit NR; }' $LTP_RUNALL_OUT") / 256;

         @system_info = `head -n $num $LTP_RUNALL_OUT`;

         if ($ltp_ver) { print RES "$ltp_ver : "; }
         print RES "$line\n\n";
         print RES "@system_info\n";
         print RES "$stat:\n ";
         print RES "@fails\n";

         $runall = `cat $LTP_RUNALL_OUT`;
         for ($j = 0; $j < $num_fail; $j++)
         {
            if ( $fails[$j] =~ m/^tag=(\w+?) / )
            { 
               $test_case = $1;
               print RES "\nTrying to find $test_case output";
               if ( $runall =~ 
                    m/(^<<<test_start>>>.tag=$test_case.*?<<<test_end>>>)/ms 
                  )
               {
                  print RES "\n-------------------------\n";
                  print RES "$1";
                  print RES "\n-------------------------\n";
               }
               else
               {  
                  print RES "\n-------------------------\n";
                  print RES "Unable to locate output for $test_case!";
                  print RES "\n-------------------------\n";
               }
            }
         }
         close(RES);
      }
      else
      { print "Can't open $RESULTS_OUT, test failures are:\n @fails\n"; }
   }
   return 1;
}

if (!download_results)
{ exit 0; }

if (!untar_results)
{ exit 0; }

if (!gather_results)
{ exit 0; }
